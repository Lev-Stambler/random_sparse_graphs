\section{A sketch for the boys}
\newcommand{\labelFunc}{\phi}
\newcommand{\imageFn}{\text{Image}}

\subsection{DAG Randomized Traversal}
Say that we have a sparse, potentially exponentially sized, graph $\graph = (\verts, \edges)$
and $\forall v \in \verts, \deg(v) = d$.
We also require that $\graph$ is equipped with a neighbor function, $\Gamma$, which can be computed in polynomial time.
% (TODO: padding).
We define a (pseudo) randomized and keyed labelling function $\phi: \verts \times \binSet^\lambda \rightarrow \binSet^{\poly(\lambda)}$ 
such that given, $\phi(K, v_0)$ for root $v_0$, an adversary, $\advers$, which does not know a path from $v_0$ to $v$,
\begin{equation}
	\label{eq:guessPhi}
	\Pr[\advers(\circNeigb, v_0, v, \labelFunc(K, v_0)) \in \imageFn(\labelFunc(K, v))] \leq \eps
\end{equation}
for some fixed $\eps \leq \negl(\lambda)$ and function $\circNeigb$ where $\circNeigb(\labelFunc(K, u)) = \labelFunc(K, \Gamma(u)_1), \dots, \labelFunc(K, \Gamma(u)_d)$
if $\Gamma(u) \neq \emptyset$ and otherwise $\Gamma(u)$ returns a $0$ string of length $d |\labelFunc(K, \cdot)|$.

\subsection{Instantiation}
We define $\labelFunc(K, v)$ to be as follows:
\begin{enumerate}
	\item Let $r_1, r_2 \randomGet \binSet^\lambda$ or $r_1, r_2$ is drawn from a pseudorandom distribution. % TODO: hmm
	\item Return $\FEEnc(\MPK, (K, v, r_2))$ where encryption is done with randomness from $r_1$.
\end{enumerate}

We can now define, $\circNeigb$.
\begin{algorithm}[H]
	\caption{
		The circuit for the neighbor function, $\circNeigb$.
	}
	\begin{algorithmic}[1]
		\Function{$\inner_i$}{$K, v, r$}
		 	\If{$\Gamma(v) = \emptyset$}
				\State \Return $0 \in \binSet^*$ %TODO: define star to just be the same length....
			\EndIf
			\State $u_1, \dots, u_d = \Gamma(v)$
			\State $u = u_i$
			\State $r_1, r_2 = \PRG(r)$
			\label{alg:neighb:prg}
			\State \Return $\FEEnc(\MPK, (u, K, r_2))$ where we encrypt with randomness from $r_1$.
		\EndFunction
		\Function{$\circNeigb$}{$\phi(K, v)$}
		 	\For{$i \in [d]$}
				\State $u_i = \Dec(\SK_{\texttt{inner}_i}, \phi(K, v))$
			\EndFor
			\State \Return $(u_1, \dots, u_d)$
		\EndFunction
	\end{algorithmic}
	\label{alg:neighb}
\end{algorithm}

Before showing that our definition of $\labelFunc$ and $\circNeigb$ satisfy \cref{eq:guessPhi}, we first must show that an adversary cannot find $K$.
\begin{lemma}
	\label{lem:findK}
	Let $\advers$ be a PPT adversary which can find $K$ with probability $N\eps$.
	Then, there exists a PPT adversary, $\adversB$ which can break the FE scheme with probability $\eps$.	
	Or, given that the FE scheme is $\eps$ secure, then,
	\begin{equation*}
		\Pr[\advers(\Gamma, \circNeigb, v_0, \labelFunc(K, v_0)) = K] \leq N\eps
	\end{equation*}
	\begin{proof}
		We first prove the above but in the case of selective security. I.e.\ the adversary has to fix
		its query path at the start.
		We then use standard complexity leveraging techniques to achieve adaptive security.

		We proceed via a series of hybrids. Note that for $|\verts| \geq \exp(\lambda)$, we require exponential hardness for the FE scheme.
		As such, let modified security parameter $\lambda' = \lambda + O(\log |\verts|)$.
		\begin{itemize}
			\item $\Hyb_0$: In the first hybrid, the following game is played
				\begin{enumerate}
					\item $K \randomGet \binSet^{\lambda'}$ and $\MPK, \SK \gets \FESetup(1^{\lambda'})$.
					\item The challenger generates $\SK_{\inner_i} \gets \FEKeygen(\MSK, \inner_i)$ for $i \in [d]$ and gives these keys to $\advers$
					\item The challenger picks random $r_1, r_2 \randomGet \binSet^{\lambda'}$ and generates $\phi(K, v_0) = \FEEnc(\MPK, (K, v_0, r_2))$ using $r_1$ as the random coins and gives $\phi(K, v_0)$ to $\advers$.
					\item $\advers$ outputs guess $K'$ and wins if $K = K'$
				\end{enumerate}
			\item $\Hyb_1$: We replace the \emph{entire graph} with its simulated counterpart.
			We start with the leaves and then ``work backwards'' doing two steps at a time.
			Let $U_1, \dots, U_D$ be a partition of $V$ such that for all $u \in U_i$, the minimum distance from $u$ to a the root is $i$.
			Starting with $j = D$, we do the following
			\begin{enumerate}
				\item For vertex $u \in U_j$, we invoke the FE simulator to get
				\begin{align*}
						\FECT_{u}' \gets \Sim\big(1^\lambda, &1^{TODO}, \MPK, (\inner_1, \dots, \inner_d), (\SK_{\inner_1}, \dots \SK_{\inner_d}),\\
							&(\inner'_1(u), \dots, \inner'_d(u))\big)
				\end{align*}
				where $\inner'_i$ is the same as $\inner_i$ except that instead of using $r_1$ as randomness for $\FEEnc$, we use $r_1'$ which is true randomness that is fixed for $u$.
				Moreover, $\inner'_i$ uses true, fixed randomness, $r_2'$, rather than $r_2$.
				\item For all $w \in \verts$ where $\Gamma(w)_i = u$, we replace $\inner'_i(\phi(K, w))$ with $\FECT_{u}'$.
				\label{alg:proof:neighb:replace}
				\item If $j \neq 1$, we go back to step 1 with $j = j - 1$.
			\end{enumerate}
		\end{itemize}
		Assuming $\Hyb_1$ and $\Hyb_0$ computational indistinguishable, if we can guess $K$, then we can build an adversary $\adversB$ which can check whether or not we are in $\Hyb_0$ or $\Hyb_3$. 
		$\adversB$ simply feeds in the distribution of $\Hyb_0$ into $\advers$ and $\Hyb_1$ into $\advers$.
		As $\Hyb_1$ is independent of K, we necessarily have that $\Pr[\advers(\Hyb_1) = K] \leq \negl(\lambda)$.

		% TODO: do we need a CRHF of K to check whether or not we are in \Hyb_0 or \Hyb_1?
		Then, we can note that if $\advers$ can guess $K$ then, $\Pr[\advers(\Hyb_0) = K] > \negl(\lambda)$.
		Thus, we have that $\Pr[\advers(\Hyb_0) = K] - \Pr[\advers(\Hyb_1) = K] > \negl(\lambda)$ and we can distinguish $\Hyb_0$ and $\Hyb_1$.	\\


		Now we just have to show that $\Hyb_0 \compInd \Hyb_1$. First, we can note
		that $\inner_i(\phi(K, u)) \compInd \inner_i'(\phi(K, u))$ as if these distributions are indistinguishable,
		we can break the security of the $\PRG$ used in line \ref{alg:neighb:prg} of \cref{alg:neighb}. 
		% TODO: more concrete?
		Now, we can note that if $\FECT_u = \phi(K, u)$, we have that $\FECT_u \compInd \FECT_u'$ are indistinguishable
		if $\inner_i(\FECT_u) \compInd \inner_i(\FECT_u')$ for all $i \in [d]$. We can note that this holds true for
		$u$ if $u$ is a leaf as $\inner_i(u) = 0$ and thus we can invoke the security of the FE simulator.
		Then, by step \ref{alg:proof:neighb:replace} in the above hybrid, we inductively create the hybrid
		such that $\inner_i(\FECT_w) \compInd \inner_i(\FECT_w')$. Thus, as we work backwards from the leaves,
		we have that $\FECT_u \compInd \FECT_u'$ for all $u \in \verts$. Assuming that the FE scheme is $\eps$ secure
		and the distance from the distributions of $\inner_i(\FECT_u)$ and $\inner_i'(\FECT_u)$ is at most $\eps$,
		then by the triangle inequality, we have that the distance between $\Hyb_0$ and $\Hyb_1$ is at most
		$O(|\verts|)\eps$.
		More formally, we have that for any PPT adversary, $\adversB$,
		\begin{equation*}
			\big| \Pr[\adversB(\Hyb_0) = 1] - \Pr[\adversB(\Hyb_1) = 1] \big| \leq O(|\verts|)\eps.
		\end{equation*}
	\end{proof}
\end{lemma}

\begin{lemma}
	\begin{equation*}
		\Pr[\advers(\Gamma, v_0, v, \labelFunc(K, v_0)) \in \imageFn(\labelFunc(K, v))] \leq \eps	
	\end{equation*}
	\begin{proof}
		\begin{itemize}
			\item We think of giving the ``null key" to the adversary. I.e.\ we give a func which always eval to null
			\item We then replace $\phi$ with its FE simulated counterpart
			\item We then say that $\labelFunc(K, v_0)^*$ is independent of $\labelFunc(K, v)$
			b/c non-malleable
			% TODO: see defn in these lectures https://www.cs.cornell.edu/courses/cs687/2006fa/lectures/lecture16.pdf
		\end{itemize}
		Assume that we can break the above hybrid. We then have that either break non-malleableness of you can find K
	\end{proof}
\end{lemma}


\begin{claim} 
	\label{claim:sec}
	\cref{eq:guessPhi} holds for any PPT adversary, $\adversB$ when $\circNeigb$ is implemented as in \cref{alg:neighb}.
\end{claim}
\begin{proof}[Proof of \cref{claim:sec}]
We proceed via a hybrid argument and then show that if there exists an adversary $\adversB$ that can beak \cref{eq:guessPhi},
then we can build an adversary $\advers$ which can distinguish between the hybrids.



% Assume that there exists a path from v_0 to v. Let all such paths be P.
% SAY THAT (definitionally) advers never queries a path from v_0 to v
% Then, we have to prove by induction that we cannot find v
% If advers does not know the path, then they do not query some subset of path \in P
% where the section is the path from u to v for some vertex u.
% Now, we can replace \inner_i(neighb u) with bot because advers (by definition) never queries u.
% Now, we need to show that finding \phi(K, u) is hard. We can do the simulation replacement as in the lemma
% But now, we have the "u" is isolated and independent of inner_i. Thus Pr[advers guesses phi(u), \phi(v_0), C_\Gamma] is about Pr[advers guesses phi(u), phi(v_0)] without gamma
% 
% Now, we have that advers never sees prior u on path. So, for next u, we can do a similar procedure as the above?
%

\begin{itemize}
	\item $\Hyb_0$: Guess game. Win if guess
	\item $\Hyb_1$: As the above but we replace $\phi(K, v_0)$ with its FE simulated counterpart
	as in the above lemma
	\item $\Hyb_2$: We replace $\inner_i$ ($\inner_i^*$) to output $\bot$ if it is supposed to output $v$
	% Oh this may actually not work, we need to say that G^-1 is hard to find...
	\item $\Hyb_3$: 

	% \item $\Hyb_1$: As the RHS of the FE game
	% \item $\Hyb_2$: As the above but we replace $\Pi_m = \big((\inner_1, \inner_1(v, K'), \dots, (\inner_d, \inner_d(v, K')\big)$
	% for all $v \in \set{v_1, ..., v_p}$
	% Secure b/c advers does not know path from u to v for any of these. Thus, C_Gamma(u) is independent of C_Gamma(v). So, all the different distributions are independent to the adversary
	% eeesh idk
\end{itemize}

Now, note that if $\adversB$ can distinguish between \cref{eq:gameGRO}, then we can build adversary $\advers$ to distinguish between $\Hyb_0$ and $\Hyb_2$ by invoking $\adversB$ to distinguish
% Ohhhh wait, because C, C(m) ~ C(m'), the simulator generating ct_m, ct_m' are indistirnguishabl from each other
% Thus, Enc(ct_m) and Enc(ct_m') are indistinguishable from each other
\end{proof}

