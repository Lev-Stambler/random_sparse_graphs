\newcommand{\MPK}{\text{MPK}}
\newcommand{\MSK}{\text{MSK}}
\newcommand{\SK}{\text{SK}}
\newcommand{\Enc}{\texttt{Enc}}
\newcommand{\Dec}{\texttt{Dec}}
\newcommand{\FEEnc}{\text{FE.Enc}}
\newcommand{\FEDec}{\text{FE.Dec}}
\newcommand{\FESetup}{\text{FE.Setup}}
\newcommand{\FEKeygen}{\text{FE.Keygen}}
\newcommand{\FECT}{\text{CT}}
\newcommand{\adversD}{\mathcal{D}}


\section{Preliminaries}
\subsection{Bounded Functional Encryption}
We will use the notation of static, bounded functional encryption as presented in
\cite{garg2022dynamic}.

\subsubsection*{Security}
% urrr... ughh we need to make this LaTeX. Low key use **nougat** for this.
We will slightly weaken the security notion such that the adversary does not choose
which circuits it can learn the functional secret key for. Indeed, this is a weaker notion of functional encryption
which fixes the adversary's output circuit.
We will assume that we get circuit $C_1, \dots, C_d$.

% See page 8 of \cite{agrawal2017functional} for now. I'll put in the actual definition later.
For completeness, we have the original security definition of \cite{garg2022dynamic} below:
\[
\begin{aligned}
&\left\{
\begin{array}{l}
\vcenter{\hbox{$\advers^{\text{KeyGen}(\MSK, \cdot)}(\mathbf{\FECT})$}}
\end{array}
\begin{array}{l}
\left(1^n, 1^q\right) \leftarrow \advers^{(1)} \\
\left(\MPK, \MSK\right) \leftarrow \text{Setup}\left(1^n, 1^q\right) \\
m \leftarrow \advers^{\text{KeyGen}(\MSK)}(\MPK) \\
\FECT \leftarrow \text{Enc}(\MPK, m)
\end{array}
\right\}_{\lambda \in \N}\\
&\compInd \\
&\left\{
\begin{array}{l}
\vcenter{\hbox{$\advers^{\Sim_3^{U_m(\cdot)}}(\FECT)$}}
\end{array}
\begin{array}{l}
\left(1^n, 1^q\right) \leftarrow \advers{(1^\lambda)} \\
\left(\MPK, \mathbf{st}_0\right) \leftarrow \Sim_0\left(1^\lambda, 1^n, q\right) \\
m \leftarrow \advers^{S_1(\mathbf{st}_0)}(\MPK) \\
\left(\FECT, \mathbf{st}_2\right) \leftarrow \Sim_2(\mathbf{st}_1, \Pi^m)
\end{array}
\right\}_{\lambda \in \N}
\end{aligned}
\]

Our modified security definition is as follows:
\begin{equation}
\label{eq:FEsec}
\begin{aligned}
	&\left\{
		\begin{array}{l}
		\vcenter{\hbox{$\advers^{\text{KeyGen}(\MSK, \cdot)}(\mathbf{\FECT})$}}
		\end{array}
		\begin{array}{l}
		\left(1^n, 1^q\right) \leftarrow \advers^{(1)} \\
		\left(\MPK, \MSK\right) \leftarrow \text{Setup}\left(1^n, 1^q\right) \\
		m \leftarrow \advers(\MPK, \SK_{C_1}, \dots, \SK_{C_d}) \\
		\FECT \leftarrow \text{Enc}(\MPK, m)
		\end{array}
	\right\}_{\lambda \in \N}\\
&\compInd \\
	&\left\{
		\begin{array}{l}
		\vcenter{\hbox{$\advers^{\Sim_3^{U_m(\cdot)}}(\FECT)$}}
		\end{array}
		\begin{array}{l}
		\left(1^n, 1^q\right) \leftarrow \advers{(1^\lambda)} \\
		\left(\MPK, \mathbf{st}_0\right) \leftarrow \Sim_0\left(1^\lambda, 1^n, q\right) \\
		m \leftarrow \advers^{S_1(\mathbf{st}_0)}(\MPK, C_1, \dots, C_d) \\
		\left(\FECT, \mathbf{st}_2\right) \leftarrow \Sim_2(\mathbf{st}_1, \Pi^m)
		\end{array}
	\right\}_{\lambda \in \N}
\end{aligned}
\end{equation}

we also copy th admissibility constraints of \cite{garg2022dynamic}:
% TODO:!

% \begin{minipage}{0.46\textwidth}
% \begin{algorithm}[H]
%     \centering
%     \caption{$\ExpReal(1^\lambda)$}
%     \begin{algorithmic}[1]
%         \State $(\MPK, \MSK) \gets \FESetup(1^\lambda)$
% 				\State $\SK_{C_i} \gets \FEKeygen(\MSK, C_i)$ for $i \in [d]$
% 				\State $x_i \gets \advers(\SK_{C_i})$
% 				\State $\FECT_i \gets \FEEnc(\MPK, x_i)$
% 				\State $\alpha \gets \advers(\FECT_1, \dots, \FECT_d)$
% 				\State \Return $x_1, \dots, x_d, \alpha$
%     \end{algorithmic}
% 		\label{alg:FEExprReal}
% \end{algorithm}
% \end{minipage}
% \hfill
% \begin{minipage}{0.46\textwidth}
% \begin{algorithm}[H]
%     \centering
%     \caption{$\ExpSim(1^\lambda)$}\label{alg:FEExprSim}
%     \begin{algorithmic}[1]
%         \State $(\MPK, \MSK) \gets \FESetup(1^\lambda)$
% 				\State $\SK_{C_i} \gets \FEKeygen(\MSK, C_i)$ for $i \in [d]$
% 				\State $x_i \gets \advers(\SK_{C_i})$
% 				\State $\FECT_i \gets \Sim(1^\lambda, 1^{|x_i|}, \MPK, C_i, \SK_{C_i}, C_i(x_i))$
% 				\State $\alpha \gets \advers(\FECT_1, \dots, \FECT_d)$
% 				\State \Return $x_1, \dots, x_d, \alpha$
%     \end{algorithmic}
% \end{algorithm}
% \end{minipage}

% TODO: change to use this definition https://eprint.iacr.org/2019/314.pdf
% because in the above we can \emph{simulate} $SK_{C_i}$.
% Actually no: use https://eprint.iacr.org/2021/847.pdf because statefulness / simplicity

% Note that the adversary $\advers$ and simulator are stateful but we do not include this in the above notation for simplicity.

\subsection{Non-malleable Bounded FE}
Here, we introduce the notion of non-malleable bounded functional encryption.
While we make the definition explicit (in terms of its non-malleability), we prove
that simulation-secure bounded FE is equivalent to simulation secure non-malleable bounded FE.

% TODO: cite https://www.cs.cornell.edu/courses/cs687/2006fa/lectures/lecture16.pdf
We define non-malleable security of bounded functional encryption in almost the exact
notion of \cite{PassNM}. First,
let $NM(m_1, \dots, m_q, \advers)$ be a game as follows for $q = \poly(\lambda)$:
\begin{enumerate}
	\item $(\MPK, \MSK) \gets \FESetup(1^\lambda)$
	\item $\SK_{C_i} \gets \FEKeygen(\MSK, C_i)$ for $i \in [d]$
	\item $\FECT_1, \dots, \FECT_q \gets \FEEnc(\MPK, m_1), \dots \FEEnc(\MPK, m_q)$
	\item $c_1', \dots, c_\ell' \gets \advers(\FECT, 1^{|m|})$
	\item $m_i' \gets \bot$ is $c_i = c_j$ for $j \in [q]$ and $\FEDec(\SK_{\text{identity}}, c_i)$ otherwise.
\end{enumerate}
Then, we say that a bounded functional encryption scheme is non-malleable if for all PPT $\advers$
and every PPT $\adversD$, there exists a negligible function $\negl$ such that
for all $\set{m}_0, \set{m}_1 \in \{0, 1\}^{nq}$, we have
\begin{equation}
	\big|\Pr[\adversD(NM(\{m\}_0, \advers)) = 1] - \Pr[\adversD(NM(\{m\}_1 , \advers)) = 1] \big|\leq \negl.
\end{equation}

As outlined in \cite{PassNM}, we can equivalently define non-malleability in terms of a PPT recognizable relation $R$
such that
\begin{align*}
	% TODO:  fix styling...
	\label{eq:NMRel}
	\bigg|\Pr&\left[NM(\{m\} , \advers(z) \in \bigcup_{m \in \{m\}} R(m)\right]- \\
				\Pr&\left[c \gets \Sim_{NM}(1^n, z); m' = \FEDec(\SK_{\text{identity}}, c); m' \in \bigcup_{m \in \{m\}} R(m)\right]\bigg| \leq \negl(\lambda).
\end{align*}
Note that in the above definition, we do not give the adversary access to any $\SK_{C_i}$.
We simply require that the scheme is public key non-malleable.

and note that
if $\SK_{C_i}$ is given to the adversary such that $\FEDec(\SK_{ID}, C_i(x)) \notin R(m)$ for all $x \in \{0, 1\}^n$,
then the scheme is still non-malleable even if the adversary is given access to $\SK_{C_i}$.
This is because we can use the FE simulator to replace $\FEEnc$ with a simulator $\Sim_{FE}$ which relies
solely on public parameters and $C_i, C_i(x)$. Indeed, as the 

Thus, we can see that given the simulator $\SK_{C_i}$ is useless
as $\FEDec(C_i(x)) \notin R(m)$.

TODO: CHANGE NM definition to be from https://www.cs.cornell.edu/~rafael/papers/PSV06a.pdf...
the adversary gets the public key


% TODO: these are not the right definitions!!! We need to basically say something a bit different
% Basically we need to say that the above holds true 

