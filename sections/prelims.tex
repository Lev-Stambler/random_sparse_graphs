\newcommand{\MPK}{\text{MPK}}
\newcommand{\MSK}{\text{MSK}}
\newcommand{\SK}{\text{SK}}
\newcommand{\Enc}{\texttt{Enc}}
\newcommand{\Dec}{\texttt{Dec}}
\newcommand{\FEEnc}{\text{FE.Enc}}
\newcommand{\FEDec}{\text{FE.Dec}}
\newcommand{\FESetup}{\text{FE.Setup}}
\newcommand{\FEKeygen}{\text{FE.Keygen}}
\newcommand{\FECT}{\text{CT}}


\section{Preliminaries}
\subsection{Bounded Functional Encryption}
We will use the notation of static, bounded functional encryption as presented in
\cite{agrawal2017functional}.

\subsubsection*{Security}
% urrr... ughh we need to make this LaTeX. Low key use **nougat** for this.
We will slightly weaken the security notion such that the adversary does not choose
which circuits it can learn the functional secret key for. Indeed, this is a weaker notion of functional encryption
which fixes the adversary's output circuit.
We will assume that we get circuit $C_1, \dots, C_d$.

See page 8 of \cite{agrawal2017functional} for now. I'll put in the actual definition later.


\begin{minipage}{0.46\textwidth}
\begin{algorithm}[H]
    \centering
    \caption*{$\ExpReal(1^\lambda)$}\label{alg:FEExprReal}
    \begin{algorithmic}[1]
        \State $(\MPK, \MSK) \gets \FESetup(1^\lambda)$
				\State $\SK_{C_i} \gets \FEKeygen(\MSK, C_i)$ for $i \in [d]$
				\State $x_i \gets \advers(\SK_{C_i})$
				\State $\FECT_i \gets \FEEnc(\MPK, x_i)$
				\State $\alpha \gets \advers(\FECT_1, \dots, \FECT_d)$
				\State \Return $x_1, \dots, x_d, \alpha$
    \end{algorithmic}
\end{algorithm}
\end{minipage}
\hfill
\begin{minipage}{0.46\textwidth}
\begin{algorithm}[H]
    \centering
    \caption*{$\ExpSim(1^\lambda)$}\label{alg:FEExprSim}
    \begin{algorithmic}[1]
        \State $(\MPK, \MSK) \gets \FESetup(1^\lambda)$
				\State $\SK_{C_i} \gets \FEKeygen(\MSK, C_i)$ for $i \in [d]$
				\State $x_i \gets \advers(\SK_{C_i})$
				\State $\FECT_i \gets \Sim(1^\lambda, 1^{|x_i|}, \MPK, C_i, \SK_{C_i}, C_i(x_i))$
				\State $\alpha \gets \advers(\FECT_1, \dots, \FECT_d)$
				\State \Return $x_1, \dots, x_d, \alpha$
    \end{algorithmic}
\end{algorithm}
\end{minipage}

Note that the adversary $\advers$ and simulator are stateful but we do not include this in the above notation for simplicity.
